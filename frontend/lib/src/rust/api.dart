// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.11.1.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import 'frb_generated.dart';
import 'models.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';

/// Get all ships from the database
Future<List<Ship>> getAllShips() => RustLib.instance.api.crateApiGetAllShips();

/// Get a single ship by ID
Future<Ship?> getShipById({required int id}) =>
    RustLib.instance.api.crateApiGetShipById(id: id);

/// Create a new ship
Future<Ship> createShip({required CreateShipRequest ship}) =>
    RustLib.instance.api.crateApiCreateShip(ship: ship);

/// Update an existing ship
Future<Ship> updateShip({required int id, required UpdateShipRequest ship}) =>
    RustLib.instance.api.crateApiUpdateShip(id: id, ship: ship);

/// Delete a ship
Future<bool> deleteShip({required int id}) =>
    RustLib.instance.api.crateApiDeleteShip(id: id);

/// Search ships by name, IMO or flag
Future<List<Ship>> searchShips({required String query}) =>
    RustLib.instance.api.crateApiSearchShips(query: query);

/// Get total ship count
Future<PlatformInt64> getShipCount() =>
    RustLib.instance.api.crateApiGetShipCount();

/// Get all orders with optional status filter
Future<List<Order>> getAllOrders({OrderStatus? statusFilter}) =>
    RustLib.instance.api.crateApiGetAllOrders(statusFilter: statusFilter);

/// Get a single order with all items
Future<OrderWithItems?> getOrderWithItems({required int id}) =>
    RustLib.instance.api.crateApiGetOrderWithItems(id: id);

/// Create a new order
Future<Order> createOrder({required CreateOrderRequest order}) =>
    RustLib.instance.api.crateApiCreateOrder(order: order);

/// Update order status (state machine enforced)
Future<Order> updateOrderStatus(
        {required int id, required OrderStatus newStatus}) =>
    RustLib.instance.api
        .crateApiUpdateOrderStatus(id: id, newStatus: newStatus);

/// Get all items for an order
Future<List<OrderItem>> getOrderItems({required int orderId}) =>
    RustLib.instance.api.crateApiGetOrderItems(orderId: orderId);

/// Add item to an order
Future<OrderItem> addOrderItem({required CreateOrderItemRequest item}) =>
    RustLib.instance.api.crateApiAddOrderItem(item: item);

/// Update order item (prices, quantity)
Future<OrderItem> updateOrderItem(
        {required int id, required UpdateOrderItemRequest item}) =>
    RustLib.instance.api.crateApiUpdateOrderItem(id: id, item: item);

/// Delete order item
Future<bool> deleteOrderItem({required int id}) =>
    RustLib.instance.api.crateApiDeleteOrderItem(id: id);

/// Calculate order totals including profit
Future<OrderTotals> calculateOrderTotals({required int orderId}) =>
    RustLib.instance.api.crateApiCalculateOrderTotals(orderId: orderId);

/// Calculate profit for a single item
Future<ItemProfit> calculateItemProfit(
        {required double buyingPrice,
        required double sellingPrice,
        required double quantity}) =>
    RustLib.instance.api.crateApiCalculateItemProfit(
        buyingPrice: buyingPrice,
        sellingPrice: sellingPrice,
        quantity: quantity);

/// Get all suppliers
Future<List<Supplier>> getAllSuppliers() =>
    RustLib.instance.api.crateApiGetAllSuppliers();

/// Get a single supplier by ID
Future<Supplier?> getSupplierById({required int id}) =>
    RustLib.instance.api.crateApiGetSupplierById(id: id);

/// Create a new supplier
Future<Supplier> createSupplier({required CreateSupplierRequest supplier}) =>
    RustLib.instance.api.crateApiCreateSupplier(supplier: supplier);

/// Update an existing supplier
Future<Supplier> updateSupplier(
        {required int id, required UpdateSupplierRequest supplier}) =>
    RustLib.instance.api.crateApiUpdateSupplier(id: id, supplier: supplier);

/// Delete a supplier
Future<bool> deleteSupplier({required int id}) =>
    RustLib.instance.api.crateApiDeleteSupplier(id: id);

/// Search suppliers by name, category, or country
Future<List<Supplier>> searchSuppliers({required String query}) =>
    RustLib.instance.api.crateApiSearchSuppliers(query: query);

/// Get suppliers by category
Future<List<Supplier>> getSuppliersByCategory({required String category}) =>
    RustLib.instance.api.crateApiGetSuppliersByCategory(category: category);

/// Get total supplier count
Future<PlatformInt64> getSupplierCount() =>
    RustLib.instance.api.crateApiGetSupplierCount();

/// Get all supply items
Future<List<SupplyItem>> getAllSupplyItems() =>
    RustLib.instance.api.crateApiGetAllSupplyItems();

/// Get a single supply item by ID
Future<SupplyItem?> getSupplyItemById({required int id}) =>
    RustLib.instance.api.crateApiGetSupplyItemById(id: id);

/// Get supply items by supplier
Future<List<SupplyItem>> getSupplyItemsBySupplier({required int supplierId}) =>
    RustLib.instance.api
        .crateApiGetSupplyItemsBySupplier(supplierId: supplierId);

/// Get supply items by category
Future<List<SupplyItem>> getSupplyItemsByCategory({required String category}) =>
    RustLib.instance.api.crateApiGetSupplyItemsByCategory(category: category);

/// Create a new supply item
Future<SupplyItem> createSupplyItem({required CreateSupplyItemRequest item}) =>
    RustLib.instance.api.crateApiCreateSupplyItem(item: item);

/// Update an existing supply item
Future<SupplyItem> updateSupplyItem(
        {required int id, required UpdateSupplyItemRequest item}) =>
    RustLib.instance.api.crateApiUpdateSupplyItem(id: id, item: item);

/// Delete a supply item
Future<bool> deleteSupplyItem({required int id}) =>
    RustLib.instance.api.crateApiDeleteSupplyItem(id: id);

/// Search supply items by name, IMPA code, or description
Future<List<SupplyItem>> searchSupplyItems({required String query}) =>
    RustLib.instance.api.crateApiSearchSupplyItems(query: query);

/// Get total supply item count
Future<PlatformInt64> getSupplyItemCount() =>
    RustLib.instance.api.crateApiGetSupplyItemCount();

/// Get all stock items
Future<List<Stock>> getAllStock() => RustLib.instance.api.crateApiGetAllStock();

/// Get stock items with low quantity (below minimum)
Future<List<Stock>> getLowStock() => RustLib.instance.api.crateApiGetLowStock();

/// Get a single stock item by ID
Future<Stock?> getStockById({required int id}) =>
    RustLib.instance.api.crateApiGetStockById(id: id);

/// Get stock by supply item ID
Future<Stock?> getStockBySupplyItem({required int supplyItemId}) =>
    RustLib.instance.api
        .crateApiGetStockBySupplyItem(supplyItemId: supplyItemId);

/// Create a new stock entry
Future<Stock> createStock({required CreateStockRequest stock}) =>
    RustLib.instance.api.crateApiCreateStock(stock: stock);

/// Update stock entry
Future<Stock> updateStock(
        {required int id, required UpdateStockRequest stock}) =>
    RustLib.instance.api.crateApiUpdateStock(id: id, stock: stock);

/// Delete stock entry
Future<bool> deleteStock({required int id}) =>
    RustLib.instance.api.crateApiDeleteStock(id: id);

/// Get stock movements for a stock item
Future<List<StockMovement>> getStockMovements({required int stockId}) =>
    RustLib.instance.api.crateApiGetStockMovements(stockId: stockId);

/// Get recent stock movements (all items)
Future<List<StockMovement>> getRecentStockMovements({required int limit}) =>
    RustLib.instance.api.crateApiGetRecentStockMovements(limit: limit);

/// Create stock movement (updates stock quantity automatically)
Future<StockMovement> createStockMovement(
        {required CreateStockMovementRequest movement}) =>
    RustLib.instance.api.crateApiCreateStockMovement(movement: movement);

/// Get stock with all movements
Future<StockWithMovements?> getStockWithMovements({required int id}) =>
    RustLib.instance.api.crateApiGetStockWithMovements(id: id);

/// Get stock summary for dashboard
Future<StockSummary> getStockSummary() =>
    RustLib.instance.api.crateApiGetStockSummary();

/// Get all ports
Future<List<Port>> getAllPorts() => RustLib.instance.api.crateApiGetAllPorts();

/// Get active ports only
Future<List<Port>> getActivePorts() =>
    RustLib.instance.api.crateApiGetActivePorts();

/// Get a single port by ID
Future<Port?> getPortById({required int id}) =>
    RustLib.instance.api.crateApiGetPortById(id: id);

/// Create a new port
Future<Port> createPort({required CreatePortRequest port}) =>
    RustLib.instance.api.crateApiCreatePort(port: port);

/// Update an existing port
Future<Port?> updatePort({required int id, required UpdatePortRequest port}) =>
    RustLib.instance.api.crateApiUpdatePort(id: id, port: port);

/// Delete a port
Future<bool> deletePort({required int id}) =>
    RustLib.instance.api.crateApiDeletePort(id: id);

/// Get ports by country
Future<List<Port>> getPortsByCountry({required String country}) =>
    RustLib.instance.api.crateApiGetPortsByCountry(country: country);

/// Get all ship visits
Future<List<ShipVisit>> getAllShipVisits() =>
    RustLib.instance.api.crateApiGetAllShipVisits();

/// Get upcoming ship visits (ETA >= today)
Future<List<ShipVisit>> getUpcomingShipVisits() =>
    RustLib.instance.api.crateApiGetUpcomingShipVisits();

/// Get ship visits by port
Future<List<ShipVisit>> getShipVisitsByPort({required int portId}) =>
    RustLib.instance.api.crateApiGetShipVisitsByPort(portId: portId);

/// Get ship visits by ship
Future<List<ShipVisit>> getShipVisitsByShip({required int shipId}) =>
    RustLib.instance.api.crateApiGetShipVisitsByShip(shipId: shipId);

/// Get a single ship visit by ID
Future<ShipVisit?> getShipVisitById({required int id}) =>
    RustLib.instance.api.crateApiGetShipVisitById(id: id);

/// Create a new ship visit
Future<ShipVisit> createShipVisit({required CreateShipVisitRequest visit}) =>
    RustLib.instance.api.crateApiCreateShipVisit(visit: visit);

/// Update an existing ship visit
Future<ShipVisit?> updateShipVisit(
        {required int id, required UpdateShipVisitRequest visit}) =>
    RustLib.instance.api.crateApiUpdateShipVisit(id: id, visit: visit);

/// Update ship visit status
Future<ShipVisit?> updateShipVisitStatus(
        {required int id, required VisitStatus status}) =>
    RustLib.instance.api.crateApiUpdateShipVisitStatus(id: id, status: status);

/// Delete a ship visit
Future<bool> deleteShipVisit({required int id}) =>
    RustLib.instance.api.crateApiDeleteShipVisit(id: id);

/// Get ship visits within a date range
Future<List<ShipVisit>> getShipVisitsByDateRange(
        {required String startDate, required String endDate}) =>
    RustLib.instance.api.crateApiGetShipVisitsByDateRange(
        startDate: startDate, endDate: endDate);

/// Get calendar data for a date range (all events + ports)
Future<CalendarData> getCalendarData(
        {required String startDate, required String endDate}) =>
    RustLib.instance.api
        .crateApiGetCalendarData(startDate: startDate, endDate: endDate);

/// Initialize the database connection with custom URL
Future<void> initDatabase({required String databaseUrl}) =>
    RustLib.instance.api.crateApiInitDatabase(databaseUrl: databaseUrl);

/// Initialize SQLite database with default local path
Future<String> initLocalDatabase() =>
    RustLib.instance.api.crateApiInitLocalDatabase();

/// Check if database is connected
Future<bool> isDatabaseConnected() =>
    RustLib.instance.api.crateApiIsDatabaseConnected();

/// Simple greet function to test FRB integration
Future<String> greet({required String name}) =>
    RustLib.instance.api.crateApiGreet(name: name);

/// Get current version info
Future<String> getVersion() => RustLib.instance.api.crateApiGetVersion();
