// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.11.1.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import 'frb_generated.dart';
import 'models.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';

/// Get all ships from the database
Future<List<Ship>> getAllShips() => RustLib.instance.api.crateApiGetAllShips();

/// Get a single ship by ID
Future<Ship?> getShipById({required int id}) =>
    RustLib.instance.api.crateApiGetShipById(id: id);

/// Create a new ship
Future<Ship> createShip({required CreateShipRequest ship}) =>
    RustLib.instance.api.crateApiCreateShip(ship: ship);

/// Update an existing ship
Future<Ship> updateShip({required int id, required UpdateShipRequest ship}) =>
    RustLib.instance.api.crateApiUpdateShip(id: id, ship: ship);

/// Delete a ship
Future<bool> deleteShip({required int id}) =>
    RustLib.instance.api.crateApiDeleteShip(id: id);

/// Search ships by name, IMO or flag
Future<List<Ship>> searchShips({required String query}) =>
    RustLib.instance.api.crateApiSearchShips(query: query);

/// Get total ship count
Future<PlatformInt64> getShipCount() =>
    RustLib.instance.api.crateApiGetShipCount();

/// Get all orders with optional status filter
Future<List<Order>> getAllOrders({OrderStatus? statusFilter}) =>
    RustLib.instance.api.crateApiGetAllOrders(statusFilter: statusFilter);

/// Get a single order with all items
Future<OrderWithItems?> getOrderWithItems({required int id}) =>
    RustLib.instance.api.crateApiGetOrderWithItems(id: id);

/// Create a new order
Future<Order> createOrder({required CreateOrderRequest order}) =>
    RustLib.instance.api.crateApiCreateOrder(order: order);

/// Update order status (state machine enforced)
Future<Order> updateOrderStatus(
        {required int id, required OrderStatus newStatus}) =>
    RustLib.instance.api
        .crateApiUpdateOrderStatus(id: id, newStatus: newStatus);

/// Get all items for an order
Future<List<OrderItem>> getOrderItems({required int orderId}) =>
    RustLib.instance.api.crateApiGetOrderItems(orderId: orderId);

/// Add item to an order
Future<OrderItem> addOrderItem({required CreateOrderItemRequest item}) =>
    RustLib.instance.api.crateApiAddOrderItem(item: item);

/// Update order item (prices, quantity)
Future<OrderItem> updateOrderItem(
        {required int id, required UpdateOrderItemRequest item}) =>
    RustLib.instance.api.crateApiUpdateOrderItem(id: id, item: item);

/// Delete order item
Future<bool> deleteOrderItem({required int id}) =>
    RustLib.instance.api.crateApiDeleteOrderItem(id: id);

/// Calculate order totals including profit
Future<OrderTotals> calculateOrderTotals({required int orderId}) =>
    RustLib.instance.api.crateApiCalculateOrderTotals(orderId: orderId);

/// Calculate profit for a single item
Future<ItemProfit> calculateItemProfit(
        {required double buyingPrice,
        required double sellingPrice,
        required double quantity}) =>
    RustLib.instance.api.crateApiCalculateItemProfit(
        buyingPrice: buyingPrice,
        sellingPrice: sellingPrice,
        quantity: quantity);

/// Get all suppliers
Future<List<Supplier>> getAllSuppliers() =>
    RustLib.instance.api.crateApiGetAllSuppliers();

/// Get a single supplier by ID
Future<Supplier?> getSupplierById({required int id}) =>
    RustLib.instance.api.crateApiGetSupplierById(id: id);

/// Create a new supplier
Future<Supplier> createSupplier({required CreateSupplierRequest supplier}) =>
    RustLib.instance.api.crateApiCreateSupplier(supplier: supplier);

/// Update an existing supplier
Future<Supplier> updateSupplier(
        {required int id, required UpdateSupplierRequest supplier}) =>
    RustLib.instance.api.crateApiUpdateSupplier(id: id, supplier: supplier);

/// Delete a supplier
Future<bool> deleteSupplier({required int id}) =>
    RustLib.instance.api.crateApiDeleteSupplier(id: id);

/// Search suppliers by name, category, or country
Future<List<Supplier>> searchSuppliers({required String query}) =>
    RustLib.instance.api.crateApiSearchSuppliers(query: query);

/// Get suppliers by category
Future<List<Supplier>> getSuppliersByCategory({required String category}) =>
    RustLib.instance.api.crateApiGetSuppliersByCategory(category: category);

/// Get total supplier count
Future<PlatformInt64> getSupplierCount() =>
    RustLib.instance.api.crateApiGetSupplierCount();

/// Get all supply items
Future<List<SupplyItem>> getAllSupplyItems() =>
    RustLib.instance.api.crateApiGetAllSupplyItems();

/// Get a single supply item by ID
Future<SupplyItem?> getSupplyItemById({required int id}) =>
    RustLib.instance.api.crateApiGetSupplyItemById(id: id);

/// Get supply items by supplier
Future<List<SupplyItem>> getSupplyItemsBySupplier({required int supplierId}) =>
    RustLib.instance.api
        .crateApiGetSupplyItemsBySupplier(supplierId: supplierId);

/// Get supply items by category
Future<List<SupplyItem>> getSupplyItemsByCategory({required String category}) =>
    RustLib.instance.api.crateApiGetSupplyItemsByCategory(category: category);

/// Create a new supply item
Future<SupplyItem> createSupplyItem({required CreateSupplyItemRequest item}) =>
    RustLib.instance.api.crateApiCreateSupplyItem(item: item);

/// Update an existing supply item
Future<SupplyItem> updateSupplyItem(
        {required int id, required UpdateSupplyItemRequest item}) =>
    RustLib.instance.api.crateApiUpdateSupplyItem(id: id, item: item);

/// Delete a supply item
Future<bool> deleteSupplyItem({required int id}) =>
    RustLib.instance.api.crateApiDeleteSupplyItem(id: id);

/// Search supply items by name, IMPA code, or description
Future<List<SupplyItem>> searchSupplyItems({required String query}) =>
    RustLib.instance.api.crateApiSearchSupplyItems(query: query);

/// Get total supply item count
Future<PlatformInt64> getSupplyItemCount() =>
    RustLib.instance.api.crateApiGetSupplyItemCount();

/// Initialize the database connection with custom URL
Future<void> initDatabase({required String databaseUrl}) =>
    RustLib.instance.api.crateApiInitDatabase(databaseUrl: databaseUrl);

/// Initialize SQLite database with default local path
Future<String> initLocalDatabase() =>
    RustLib.instance.api.crateApiInitLocalDatabase();

/// Check if database is connected
Future<bool> isDatabaseConnected() =>
    RustLib.instance.api.crateApiIsDatabaseConnected();

/// Simple greet function to test FRB integration
Future<String> greet({required String name}) =>
    RustLib.instance.api.crateApiGreet(name: name);

/// Get current version info
Future<String> getVersion() => RustLib.instance.api.crateApiGetVersion();
