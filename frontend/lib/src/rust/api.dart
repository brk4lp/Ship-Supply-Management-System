// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.11.1.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import 'frb_generated.dart';
import 'models.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';

/// Get all ships from the database
Future<List<Ship>> getAllShips() => RustLib.instance.api.crateApiGetAllShips();

/// Get a single ship by ID
Future<Ship?> getShipById({required int id}) =>
    RustLib.instance.api.crateApiGetShipById(id: id);

/// Create a new ship
Future<Ship> createShip({required CreateShipRequest ship}) =>
    RustLib.instance.api.crateApiCreateShip(ship: ship);

/// Update an existing ship
Future<Ship> updateShip({required int id, required UpdateShipRequest ship}) =>
    RustLib.instance.api.crateApiUpdateShip(id: id, ship: ship);

/// Delete a ship
Future<bool> deleteShip({required int id}) =>
    RustLib.instance.api.crateApiDeleteShip(id: id);

/// Get all orders with optional status filter
Future<List<Order>> getAllOrders({OrderStatus? statusFilter}) =>
    RustLib.instance.api.crateApiGetAllOrders(statusFilter: statusFilter);

/// Get a single order with all items
Future<OrderWithItems?> getOrderWithItems({required int id}) =>
    RustLib.instance.api.crateApiGetOrderWithItems(id: id);

/// Create a new order
Future<Order> createOrder({required CreateOrderRequest order}) =>
    RustLib.instance.api.crateApiCreateOrder(order: order);

/// Update order status (state machine enforced)
Future<Order> updateOrderStatus(
        {required int id, required OrderStatus newStatus}) =>
    RustLib.instance.api
        .crateApiUpdateOrderStatus(id: id, newStatus: newStatus);

/// Add item to an order
Future<OrderItem> addOrderItem({required CreateOrderItemRequest item}) =>
    RustLib.instance.api.crateApiAddOrderItem(item: item);

/// Update order item (prices, quantity)
Future<OrderItem> updateOrderItem(
        {required int id, required UpdateOrderItemRequest item}) =>
    RustLib.instance.api.crateApiUpdateOrderItem(id: id, item: item);

/// Delete order item
Future<bool> deleteOrderItem({required int id}) =>
    RustLib.instance.api.crateApiDeleteOrderItem(id: id);

/// Calculate order totals including profit
Future<OrderTotals> calculateOrderTotals({required int orderId}) =>
    RustLib.instance.api.crateApiCalculateOrderTotals(orderId: orderId);

/// Calculate profit for a single item
Future<ItemProfit> calculateItemProfit(
        {required double buyingPrice,
        required double sellingPrice,
        required double quantity}) =>
    RustLib.instance.api.crateApiCalculateItemProfit(
        buyingPrice: buyingPrice,
        sellingPrice: sellingPrice,
        quantity: quantity);

/// Get all suppliers
Future<List<Supplier>> getAllSuppliers() =>
    RustLib.instance.api.crateApiGetAllSuppliers();

/// Create a new supplier
Future<Supplier> createSupplier({required CreateSupplierRequest supplier}) =>
    RustLib.instance.api.crateApiCreateSupplier(supplier: supplier);

/// Initialize the database connection
Future<void> initDatabase({required String databaseUrl}) =>
    RustLib.instance.api.crateApiInitDatabase(databaseUrl: databaseUrl);

/// Check if database is connected
Future<bool> isDatabaseConnected() =>
    RustLib.instance.api.crateApiIsDatabaseConnected();

/// Simple greet function to test FRB integration
Future<String> greet({required String name}) =>
    RustLib.instance.api.crateApiGreet(name: name);

/// Get current version info
Future<String> getVersion() => RustLib.instance.api.crateApiGetVersion();
